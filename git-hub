#!/usr/bin/env python
# vim: set fileencoding=utf-8 :

"""\
Git command line interface to GitHub.

Written by Leandro Lucarella <leandro.lucarella@sociomantic.com>.
"""

import sys
import json
import string
import base64
import urllib
import urllib2
import getpass
import os.path
import argparse
import subprocess


def out(msg):
	sys.stdout.write(msg)

def outf(fmt='', *args, **kwargs):
	sys.stdout.write(fmt.format(*args, **kwargs) + '\n')

def errf(fmt='', *args, **kwargs):
	if sys.stderr.isatty():
		sys.stderr.write('\033[31m')
	sys.stderr.write('Error: ')
	sys.stderr.write(fmt.format(*args, **kwargs))
	if sys.stderr.isatty():
		sys.stderr.write('\033[0m')
	sys.stderr.write('\n')
	sys.stderr.flush()

def die(fmt='', *args, **kwargs):
	errf(fmt, *args, **kwargs)
	sys.exit(1)


GIT_CONFIG_PREFIX = 'hub.'

def git(*args, **kwargs):
	if len(args) == 1:
		args = args[0].split()
	else:
		args = list(args)
	return subprocess.check_output(['git'] + args, **kwargs).rstrip('\n')

def git_config(name, default=None, prefix=GIT_CONFIG_PREFIX, value=None):
	name = prefix + name
	try:
		if value is None:
			return git('config', name)
		return git('config', name, value)
	except subprocess.CalledProcessError as e:
		if e.returncode == 1:
			if default is not None:
				return default
			die("Can't find '{}' config key in git config",
					name)
		raise e


def editor(help_msg, msg=None):
	prog = git('var', 'GIT_EDITOR')
	dotgit = git('rev-parse', '--git-dir')
	fname = os.path.join(dotgit, 'HUB_EDITMSG')
	with file(fname, 'w') as f:
		f.write(msg or '')
		f.write(help_msg)
	status = subprocess.call([prog, fname])
	if status != 0:
		die("Editor returned {}, aborting...", status)
	with file(fname) as f:
		msg = f.read()
	return msg


class Config:

	def __init__(self):
		self.username = git_config('username', getpass.getuser())
		self.password = git_config('password')
		self.upstream = git_config('upstream', '')
		if self.upstream and '/' not in self.upstream:
			die("Invalid hub.upstream configuration, '/' not found")
		self.forkrepo = git_config('forkrepo', '')
		if not self.forkrepo and self.upstream:
			upstream = self.upstream.split('/')
			self.forkrepo = self.username + '/' + upstream[1]
		self.forkremote = git_config('forkremote', 'origin')
		self.pullbase = git_config('pullbase', 'master')
		self.urltype = git_config('urltype', 'ssh_url')

	def check(self, name):
		if getattr(self, name) is None:
			die("Can't find '{}{}' config key in git config",
					GIT_CONFIG_PREFIX, name)


# Manages GitHub request handling authentication and content headers.
#
# The real interesting methods are created after the class declaration, for
# each type of request: head(), get(), post(), patch(), put() and delete().
#
# All these methods take an URL (relative to the base_url) and optionally an
# arbitrarily number of positional or keyword arguments (but not both at the
# same type). The extra arguments, if present, are serialized as json and sent
# as the request body.
# All these methods return None if the response is empty, or the deserialized
# json data received in the body of the response.
#
# Example:
#
#    r = req.post('/repos/sociomantic/test/labels/', name=name, color=color)
#
# See http://developer.github.com/ for more details on the GitHub API
class RequestManager:

	base_url = 'https://api.github.com'

	def auth_urlopen(self, url, method, body):
		req = urllib2.Request(self.base_url + url, body)
		auth_str = base64.urlsafe_b64encode("%s:%s" %
			(config.username, config.password))
		req.add_header("Authorization", "Basic " + auth_str)
		req.add_header("Content-Type", "application/json")
		req.add_header("Accept", "application/json")
		req.add_header("Content-Length", str(len(body) if body else 0))
		req.get_method = lambda: method
		#print req.get_full_url()
		#print req.header_items()
		#print req.get_data()
		return urllib2.urlopen(req)

	def dump(self, *args, **kwargs):
		if args and kwargs:
			raise ValueError('args and kwargs are mutually '
				'exclusive')
		if args:
			return json.dumps(args)
		if kwargs:
			return json.dumps(kwargs)
		return None

	def json_req(self, url, method, *args, **kwargs):
		if method.lower() in ('post', 'patch', 'put'):
			body = self.dump(*args, **kwargs)
		else:
			body = None
			url += '?' + urllib.urlencode(kwargs)
		res = self.auth_urlopen(url, method, body)
		data = res.read()
		if data:
			return json.loads(data)
		return None

# Create RequestManager.head(), get(), ... methods
# We need the make_method() function to make Python bind the method variable
# (from the loop) early (in the loop) instead of when is called. Otherwise all
# methods get bind with the last value of method ('delete') in this case, which
# is not only what we want, is also very dangerous.
def make_method(method):
	return lambda self, url, *args, **kwargs: \
		self.json_req(url, method.upper(), *args, **kwargs)
for method in ('head', 'get', 'post', 'patch', 'put', 'delete'):
	setattr(RequestManager, method, make_method(method))


def check_empty_message(msg):
	if not msg.strip():
		die("Message is empty, aborting...")
	return msg

message_markdown_help = '''\
# Remember GitHub will parse comments and descriptions as GitHub
# Flavored Markdown. For details see:
# http://github.github.com/github-flavored-markdown/
#
# Lines starting with '# ' (note the space after the hash!) will be
# ignored, and an empty message aborts the command. The space after the
# hash is required by comments to avoid accidentally commenting out a
# line starting with a reference to an issue (#4 for example). If you
# want to include Markdown headers in your message, use the Setext-style
# headers, which consist on underlining titles with '=' for first-level
# or '-' for second-level headers.
'''
def clean_message(msg):
	lines = msg.splitlines()
	# Remove comment lines
	lines = [l for l in lines if not l.strip().startswith('#')]
	return '\n'.join(lines)

def split_titled_message(msg):
	lines = check_empty_message(clean_message(msg)).splitlines()
	title = lines[0]
	body = ''
	if len(lines) > 1:
		if lines[1].strip():
			die("Wrong message format, leave an "
				"empty line between the title "
				"and the body")
		body = '\n'.join(lines[2:])
	return (title, body)


class CmdGroup (object):

	subcommand_suffix = 'Cmd'

	@classmethod
	def setup_parser(cls, parser):
		suffix = cls.subcommand_suffix
		subcommands = [getattr(cls, a) for a in dir(cls)
				if a.endswith(suffix)]
		if not subcommands:
			return
		title = None
		if hasattr(cls, 'cmd_title'):
			title = cls.cmd_title
		subparsers = parser.add_subparsers(title=title)
		for cmd in subcommands:
			name = cmd.__name__.lower()[:-len(suffix)]
			if hasattr(cmd, 'cmd_name'):
				name = cmd.cmd_name
			help = cmd.__doc__
			if hasattr(cmd, 'cmd_help'):
				help = cmd.cmd_help
			p = subparsers.add_parser(name, help=help)
			cmd.setup_parser(p)
			if not hasattr(cmd, 'run'):
				continue
			if hasattr(cmd, 'cmd_required_config'):
				def make_closure(cmd):
					def check_config_and_run(parser, args):
						for c in cmd.cmd_required_config:
							config.check(c)
						cmd.run(parser, args)
					return check_config_and_run
				p.set_defaults(run=make_closure(cmd))
			else:
				p.set_defaults(run=cmd.run)


class CloneCmd (object):

	cmd_help = 'clone a GitHub repository'

	@classmethod
	def setup_parser(cls, parser):
		parser.add_argument('origin', metavar='ORIGIN',
			help="name of the repository to be cloned in "
			"<owner>/<project> format (if <owner> is omitted, the "
			"configuration 'hub.username' is used as <owner>)")
		parser.add_argument('-u', '--upstream', metavar='UPSTREAM',
			help="name of the repository to be user as upstream in "
			"<owner>/<project> format (will be saved in the "
			"'hub.upstream' configuration variable in the new "
			"cloned repository); if the <project> part is "
			"omitted, the ORIGIN <project> part is used")
	@classmethod
	def run(cls, parser, args):
		origin = args.origin
		if '/' not in origin:
			origin = config.username + '/' + origin
		repo = req.get('/repos/' + origin)
		git('clone', repo[config.urltype])
		if args.upstream:
			upstream = args.upstream
			if '/' not in upstream:
				_, proj = origin.split('/', 1)
				upstream = upstream + '/' + proj
			os.chdir(repo['name'])
			git_config('upstream', value=upstream)


class IssueUtil (object):

	cmd_required_config = ['upstream']
	name = 'pull request'
	gh_path = 'issues'
	id_var = 'ISSUE'
	help_msg = '''
# Please enter the title and description below.
#
# The first line is interpreted as the title. An optional description
# can follow after and empty line. For example:
#
#   Some title
#
#   Some description that can span several
#   lines.
#
''' + message_markdown_help
	comment_help_msg = '''
# Please enter your comment below.
#
''' + message_markdown_help

	@classmethod
	def print_issue(cls, issue):
		outf('[{number}] {title} ({user[login]})\n{}{html_url}',
				' ' * (len(str(issue['number'])) + 3),
				**issue)

	@classmethod
	def print_comment(cls, comment):
		body = comment['body']
		outf('[{id}] {}{} ({user[login]})', body[:60],
				'â€¦' if len(body) > 60 else '',
				' ' * (len(str(comment['id'])) + 3),
				**comment)

	@classmethod
	def url(cls, number=None):
		s = '/repos/%s/%s' % (config.upstream, cls.gh_path)
		if number:
			s += '/' + number
		return s

	@classmethod
	def editor(cls, msg=None):
		return editor(cls.help_msg, msg)

	@classmethod
	def comment_editor(cls, msg=None):
		return editor(cls.comment_help_msg, msg)

	@classmethod
	def clean_and_post_comment(cls, issue_num, body):
		# URL fixed to issues, pull requests comments are made through
		# issues
		url = '/repos/%s/issues/%s/comments' % (config.upstream,
				issue_num)
		body = check_empty_message(clean_message(body))
		comment = req.post(url, body=body)
		cls.print_comment(comment)

class IssueCmd (CmdGroup):

	cmd_title = 'subcommands to manage issues'
	cmd_help = 'manage issues'

	class ListCmd (IssueUtil):
		cmd_help = "show a list of open %ss" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('-c', '--closed',
				action='store_true', default=False,
				help="show only closed pull requests")
		@classmethod
		def run(cls, parser, args):
			state = 'closed' if args.closed else 'open'
			issues = req.get(cls.url(), state=state)
			for issue in issues:
				cls.print_issue(issue)

	class ShowCmd (IssueUtil):
		cmd_help = "show details for existing %ss" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issues',
				nargs='+', metavar=cls.id_var+'S',
				help="numbers identifying the issues to show")
		@classmethod
		def run(cls, parser, args):
			for number in args.issues:
				issue = req.get(cls.url(number))
				cls.print_issue(issue)

	class NewCmd (IssueUtil):
		cmd_help = "create a new %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('-m', '--message', metavar='MSG',
				help="issue's title (and description); the "
				"first line is used as the issue title and "
				"any text after an empty line is used as "
				"the optional body")
			parser.add_argument('-l', '--label',
				metavar='LABEL', action='append',
				help="attach LABEL to the issue (can be "
				"specified multiple times to set multiple "
				"labels)")
			parser.add_argument('-a', '--assign', metavar='USER',
				help="assign an user to the issue; must be a "
				"valid GitHub login name")
			parser.add_argument('-M', '--milestone', metavar='ID',
				help="assign the milestone identified by the "
				"number ID to the issue")
		@classmethod
		def run(cls, parser, args):
			msg = args.message or cls.editor()
			(title, body) = split_titled_message(msg)
			issue = req.post(cls.url(), title=title, body=body,
				assignee=args.assignee, labels=args.labels,
				milestone=args.milestone)
			cls.print_issue(issue)

	class UpdateCmd (IssueUtil):
		cmd_help = "update an existing %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to update")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="new issue title (and description); the "
				"first line is used as the issue title and "
				"any text after " "an empty line is used as "
				"the optional body")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to edit the "
				"current title (and description) of the issue")
			parser.add_argument('-o', '--open',
				action='store_true', default=False,
				help="reopen the issue")
			parser.add_argument('-c', '--close',
				action='store_true', default=False,
				help="close the issue")
			parser.add_argument('-l', '--label',
				metavar='LABEL', action='append',
				help="if one or more labels are specified, "
				"they will replace the current issue labels; "
				"otherwise the labels are unchanged. If one of "
				"the labels is empty, the labels will be "
				"cleared (so you can use -l'' to clear the "
				"labels of an issue)")
			parser.add_argument('-a', '--assign', metavar='USER',
				help="assign an user to the issue; must be a "
				"valid GitHub login name")
			parser.add_argument('-M', '--milestone', metavar='ID',
				help="assign the milestone identified by the "
				"number ID to the issue")
		@classmethod
		def run(cls, parser, args):
			# URL fixed to issues, pull requests updates are made
			# through issues to allow changing labels, assignee and
			# milestone (even when GitHub itself doesn't support it
			# :D)
			url = '/repos/%s/issues/%s' % (config.upstream,
					args.issue)
			params = dict()
			# Should labels be cleared?
			if (args.labels and len(args.labels) == 1 and
					not args.labels[0]):
				params['labels'] = []
			elif args.labels:
				params['labels'] = args.labels
			if args.open:
				params['state'] = 'open'
			if args.close:
				params['state'] = 'closed'
			if args.assign is not None:
				params['assignee'] = args.assign
			if args.milestone is not None:
				params['milestone'] = args.milestone
			msg = args.message
			if args.edit_message:
				if not msg:
					issue = req.get(url)
					msg = issue['title']
					if issue['body']:
						msg += '\n\n' + issue['body']
				msg = cls.editor(msg)
				(title, body) = split_titled_message(msg)
				params['title'] = title
				params['body'] = body
			issue = req.patch(url, **params)
			cls.print_issue(issue)

	class CommentCmd (IssueUtil):
		cmd_help = "add a comment to an existing %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to close")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="comment to be added to the issue; if "
				"this option is not used, the default "
				"$GIT_EDITOR is opened to write the comment")
		@classmethod
		def run(cls, parser, args):
			body = args.message or cls.comment_editor()
			cls.clean_and_post_comment(args.issue, body)

	class CloseCmd (IssueUtil):
		cmd_help = "close an opened %s" % IssueUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar=cls.id_var,
				help="number identifying the issue to close")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="add a comment to the issue before "
				"closing it")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to write "
				"a comment to be added to the issue before "
				"closing it")
		@classmethod
		def run(cls, parser, args):
			msg = args.message
			if args.edit_message:
				msg = cls.comment_editor(msg)
			if msg:
				cls.clean_and_post_comment(args.issue, msg)
			issue = req.patch(cls.url(args.issue), state='closed')
			cls.print_issue(issue)


class PullUtil (IssueUtil):

	name = 'pull request'
	gh_path = 'pulls'
	id_var = 'PULL'
	rebase_msg = 'This pull request has been rebased via ' \
			'`git hub pull rebase` and the new HEAD is {}'

	@classmethod
	def head_ref(cls):
		return git('rev-parse --abbrev-ref HEAD')

	@classmethod
	def push(cls, head):
		local = git('rev-parse', head)
		remote = 'x' # dummy variable that doesn't match any git hash
		remote_head = '%s/%s' % (config.forkremote, head)
		status = subprocess.call('git rev-parse --verify --quiet ' +
				remote_head + ' > /dev/null', shell=True)
		if status == 0: # remote reference found, get the hash
			remote = git('rev-parse', remote_head)
		if local != remote:
			git('push', config.forkremote, head+':'+head)

	@classmethod
	def get_default_branch_msg(cls, branch_name):
		msg = git_config('branch.%s.description' % branch_name, '', '')
		if msg:
			return msg
		return git('log -1 --pretty=format:%s%n%n%b ' + branch_name)

class PullCmd (IssueCmd):

	cmd_title = 'subcommands to manage pull requests'
	cmd_help = 'manage pull requests'

	class ListCmd (PullUtil, IssueCmd.ListCmd):
		pass

	class ShowCmd (PullUtil, IssueCmd.ShowCmd):
		pass

	class UpdateCmd (PullUtil, IssueCmd.UpdateCmd):
		pass

	class CommentCmd (PullUtil, IssueCmd.CommentCmd):
		pass

	class CloseCmd (PullUtil, IssueCmd.CloseCmd):
		pass

	class NewCmd (PullUtil):
		cmd_help = "create a new %s" % PullUtil.name
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('head', metavar='HEAD', nargs='?',
				help="branch (or git ref) where your changes "
				"are implemented")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="pull request title (and description); "
				"the first line is used as the pull request "
				"title and any text after an empty line is "
				"used as the optional body")
			parser.add_argument('-b', '--base', metavar='BASE',
				help="branch (or git ref) you want your "
				"changes pulled into (uses hub.pullbase or "
				"'master' in hub.upstream by default)")
		@classmethod
		def run(cls, parser, args):
			head = args.head or cls.head_ref()
			base = args.base or config.pullbase
			msg = args.message
			gh_head = config.username + ':' + head
			if not msg:
				msg = cls.editor(cls.get_default_branch_msg(head))
			(title, body) = split_titled_message(msg)
			cls.push(head)
			pull = req.post(cls.url(), head=gh_head, base=base,
					title=title, body=body)
			cls.print_issue(pull)

	class AttachCmd (PullUtil):
		cmd_help = "attach code to an existing issue"
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('issue', metavar='ISSUE',
				help="issue ID to attach code to")
			parser.add_argument('head', metavar='HEAD', nargs='?',
				help="branch (or git ref) where your changes "
				"are implemented")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="add a comment to the issue/new pull "
				"request")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to write "
				"a comment to be added to the issue after "
				"attaching the code to it")
			parser.add_argument('-b', '--base', metavar='BASE',
				help="branch (or git ref) you want your "
				"changes pulled into (uses hub.pullbase or "
				"'master' in hub.upstream by default)")
		@classmethod
		def run(cls, parser, args):
			head = args.head or cls.head_ref()
			base = args.base or config.pullbase
			msg = args.message
			if args.edit_message:
				if not msg:
					msg = cls.get_default_branch_msg(head)
				msg = cls.comment_editor(msg)
			gh_head = config.username + ':' + head
			cls.push(head)
			pull = req.post(cls.url(), issue=args.issue, base=base,
					head=gh_head)
			cls.print_issue(pull)
			if msg:
				cls.clean_and_post_comment(args.issue, msg)

	class RebaseCmd (PullUtil):
		cmd_help = "close a pull request by rebasing its base branch"
		@classmethod
		def setup_parser(cls, parser):
			parser.add_argument('pull', metavar=cls.id_var,
				help="number identifying the pull request "
				"to rebase")
			parser.add_argument('-m', '--message', metavar='MSG',
				help="add a comment to the pull request before "
				"closing it; if not specified a default "
				"comment is added (to avoid adding a comment "
				"at all use -m'')")
			parser.add_argument('-e', '--edit-message',
				action='store_true', default=False,
				help="open the default $GIT_EDITOR to edit "
				"the comment to be added to the pull request "
				"before closing it")
		@classmethod
		def run(cls, parser, args):
			# TODO: Add rebase --continue --abort --skip
			pull = req.get(cls.url(args.pull))
			head_url = pull['head']['repo'][config.urltype]
			head_ref = pull['head']['ref']
			base_url = pull['base']['repo'][config.urltype]
			base_ref = pull['base']['ref']
			tmp_ref = 'git-hub-pull-rebase-%s' % args.pull
			old_ref = cls.head_ref()
			stashed_before = git('stash list')
			stashed = False
			git('stash save --all "Stashed by git hub pull rebase '
				'to rebase pull request %s"' % args.pull)
			if stashed_before != git('stash list'):
				stashed = True
			try:
				git('fetch', head_url, head_ref)
				git('checkout', '-b', tmp_ref, 'FETCH_HEAD')
				try:
					git('pull', '--rebase', base_url, base_ref)
					git('push', base_url, 'HEAD:' + base_ref)
					pushed_sha = git('rev-parse HEAD')
				finally:
					git('reset', '--hard') # just in case of errors
					git('checkout', old_ref)
					git('branch', '-D', tmp_ref)
			finally:
				if stashed:
					git('stash', 'pop')
			msg = args.message or cls.rebase_msg.format(pushed_sha)
			if args.edit_message:
				msg = cls.comment_editor(msg)
			if msg:
				cls.clean_and_post_comment(args.pull, msg)
			pull = req.get(cls.url(args.pull))
			if pull['state'] == 'open':
				pull = req.patch(cls.url(args.pull), state='closed')
			cls.print_issue(pull)


class HubCmd (CmdGroup):
	cmd_title = "subcommands"
	cmd_help = "git command line interface to GitHub"
	CloneCmd = CloneCmd
	IssueCmd = IssueCmd
	PullCmd = PullCmd


def main():
	global args, config, req

	parser = argparse.ArgumentParser(
			description='Git command line interface to GitHub')
	parser.add_argument('--version', action='version', version='git-hub 0.1')
	HubCmd.setup_parser(parser)
	args = parser.parse_args()

	config = Config()

	req = RequestManager()

	args.run(parser, args)


if __name__ == '__main__':
	try:
		main()
	except urllib2.HTTPError as error:
		try:
			err = json.loads(error.read())
			prefix = 'GitHub error: '
			if 'message' in err:
				errf('{}{message}', prefix, **err)
			if 'errors' in err:
				for e in err['errors']:
					if 'message' in err:
						errf('{}{message}',
							' ' * len(prefix), **e)
		except:
			errf('{}', error)
			errf('{}', error.read())
			errf('{}', error.geturl())
			errf('{}', error.headers)
			sys.exit(3)
		sys.exit(4)


